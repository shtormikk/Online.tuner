<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Онлайн тюнер для акустической гитары</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 40px; background: #f7f7f7; }
    h1 { margin-bottom: 10px; }
    #status { margin-bottom: 20px; color: #555; }
    #note { font-size: 72px; font-weight: bold; margin: 20px 0; }
    #detune { font-size: 28px; color: #333; }
    .btn { padding: 12px 20px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer; margin: 6px; }
    .btn.primary { background: #4CAF50; color: white; }
    .btn.secondary { background: #e0e0e0; }
    #meter { width: 100%; height: 20px; background: #ddd; border-radius: 10px; overflow: hidden; margin-top: 10px; }
    #meter > span { display: block; height: 100%; width: 0%; background: #4CAF50; }
  </style>
</head>
<body>
  <h1>Онлайн тюнер для акустической гитары</h1>
  <div id="status">Найти звук... Подключение к микрофону</div>

  <div id="note">—</div>
  <div id="detune">detune: —</div>
  <div id="meter"><span></span></div>

  <div>
    <button id="startBtn" class="btn primary">Начать</button>
    <button id="stopBtn" class="btn secondary" disabled>Стоп</button>
  </div>

  <script>
    // Ноты и частоты (приближенно, A4 = 440 Гц)
    const A4 = 440;
    const SEMIS_IN_OCTAVE = 12;
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    // Значение частоты для одной ноты по MIDI-номеру
    function freqFromNoteNumber(n) {
      // MIDI note 69 = A4 = 440 Hz
      return 440 * Math.pow(2, (n - 69) / 12);
    }

    // Поиск ближайшей ноты к частоте
    function closestNoteAndDetune(freq) {
      if (freq <= 0) return { note: "", detuneCents: 0, noteName: "" };
      // Преобразуем частоту в MIDI номер
      const midi = 69 + 12 * Math.log2(freq / A4);
      const midiRound = Math.round(midi);
      const detuneCents = Math.round((midi - midiRound) * 100);
      // Баланс названия ноты
      const octave = Math.floor(midiRound / 12) - 1;
      const noteIndex = (midiRound % 12 + 12) % 12;
      const noteName = noteNames[noteIndex] + octave;
      return { note: midiRound, noteName, detuneCents };
    }

    let audioCtx;
    let analyser;
    let dataArray;
    let bufferLength;

    const statusEl = document.getElementById('status');
    const noteEl = document.getElementById('note');
    const detuneEl = document.getElementById('detune');
    const meter = document.getElementById('meter').firstElementChild;

    document.getElementById('startBtn').addEventListener('click', start);
    document.getElementById('stopBtn').addEventListener('click', stop);

    function start() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusEl.textContent = "Браузер не поддерживает getUserMedia";
        return;
      }

      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(stream);
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 2048;
          bufferLength = analyser.fftSize;
          dataArray = new Float32Array(bufferLength);
          source.connect(analyser);

          statusEl.textContent = "Готово. Нужное звучание?";
          document.getElementById('startBtn').disabled = true;
          document.getElementById('stopBtn').disabled = false;

          // Запуск цикла анализа
          requestAnimationFrame(tick);
        })
        .catch(err => {
          statusEl.textContent = "Ошибка доступа к микрофону: " + err.message;
        });
    }

    function stop() {
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      statusEl.textContent = "Остановлено";
      noteEl.textContent = "—";
      detuneEl.textContent = "detune: —";
      meter.style.width = "0%";
    }

    function tick() {
      if (!analyser) return;
      // Получаем временной сигнал
      analyser.getFloatTimeDomainData(dataArray);

      // Простейшее вычисление частоты: Autocorrelation
      const freq = autoCorrelate(dataArray, audioCtx.sampleRate);
      if (freq && isFinite(freq)) {
        const { noteName, detuneCents } = closestNoteAndDetune(freq);
        noteEl.textContent = noteName;
        detuneEl.textContent = "detune: " + (detuneCents >= 0 ? "+" : "") + detuneCents + " центов";

        // Визуализация: заполнение шкалы процента по доли отклонения
        const detuneAbs = Math.abs(detuneCents);
        const width = Math.min(100, (detuneAbs / 50) * 100); // ориентировочно +/-50 центов вокруг ноты
        meter.style.width = width + "%";
        meter.style.background = detuneCents === 0 ? "#4CAF50" : "#4CAF50";
      } else {
        noteEl.textContent = "—";
        detuneEl.textContent = "detune: —";
        meter.style.width = "0%";
      }

      requestAnimationFrame(tick);
    }

    // Autocorrelation-based frequency estimator
    function autoCorrelate(buffer, sampleRate) {
      //Calculates a rough pitch in Hz using autocorrelation
      let SIZE = buffer.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        const val = buffer[i];
        rms += val * val;
      }
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) // слишком тихо
        return 0;

      let corr = new Array(2048).fill(0);
      for (let lag = 0; lag < SIZE; lag++) {
        let sum = 0;
        for (let i = 0; i < SIZE - lag; i++) {
          sum += buffer[i] * buffer[i + lag];
        }
        corr[lag] = sum;
      }

      // Найти лаг с максимальным корреляционным значением
      let d = 0;
      while (d < corr.length && corr[d] > corr[d + 1]) d++;
      let maxCorr = 0;
      let maxLag = 0;
      for (let i = d; i < corr.length; i++) {
        if (corr[i] > maxCorr) {
          maxCorr = corr[i];
          maxLag = i;
        }
      }

      const T0 = maxLag;
      if (T0 === 0) return 0;

      // Частота
      const freq = sampleRate / T0;
      // Фильтр незначительных частот
      if (freq < 82 || freq > 1000) return 0;
      return freq;
    }

  </script>
</body>
</html>
